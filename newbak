#!/usr/bin/env python3
# vim: textwidth=120
# pylint: disable=line-too-long,broad-exception-caught,redefined-outer-name
# pylint: disable=too-many-branches,too-many-statements,too-many-return-statements
"""
newbak - Incremental Backup Automation Tool

Automates incremental backups of a local Linux system onto connected LUKS-encrypted disks
using rsnapshot. Also provides explicit open/close commands.
"""
import sys
import subprocess
import os
import datetime
import json
import re
import getpass
from pathlib import Path
import yaml

# --- Constants and Configuration ---
LOG_FILE = 'newbak.log'
DEFAULT_ROTATION = 'hourly'
ALLOWED_PERIODS = ['hourly', 'daily', 'weekly', 'monthly']
MAIN_COMMANDS = ['backup', 'close', 'open', 'force-open', 'fsck', 'help']
UUID_REGEX = re.compile(r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$', re.IGNORECASE)
CONFIG_PATHS = [
    Path('.'),
    Path('~/.config/newbak').expanduser()
]
CONFIG_FILE_NAME = 'newbak-conf.yaml'


# pylint: disable=redefined-builtin
def log_operation(message, type='INFO'):
    """Logs a message with a strict timestamp format to the LOG_FILE."""
    timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    # Determine the prefix based on the type for the required log format
    if type == 'START':
        prefix = ' ,----- '
    elif type == 'END':
        prefix = ' `----- '
    else:
        prefix = ' | '

    log_entry = f"{timestamp}{prefix}{message}\n"
    print(log_entry, end='')

    try:
        with open(LOG_FILE, 'a', encoding='utf8') as f:
            f.write(log_entry)
    except Exception as e:
        print(f"{timestamp} | ERROR: Failed to write to log file {LOG_FILE}: {e}", file=sys.stderr)


def abort(message, command_line=None):
    """Logs an error message and exits the script."""
    log_operation(f"ERROR: {message}", 'ERROR')
    if command_line:
        log_operation(command_line + ' ended', 'END')
    sys.exit(1)


def parse_args(args):
    """
    Handles argument parsing for command and target.
    The 'backup' command is assumed if the first argument is not a known command.
    """
    if not args:
        return 'help', None, None

    if args[0].lower() in MAIN_COMMANDS:
        command = args[0].lower()
        remaining = args[1:]
    else:
        command = 'backup'
        remaining = args

    if command == 'help':
        return 'help', None, None

    target_id = None
    rotation = DEFAULT_ROTATION

    for arg in remaining:
        arg_lower = arg.lower()
        if arg_lower in ALLOWED_PERIODS and command == 'backup':
            rotation = arg_lower
        else:
            # The most recent non-rotation argument is treated as the target
            target_id = arg

    if not target_id:
        abort(f"Command '{command}' requires a target (friendlyname or UUID).")

    return command, target_id, rotation


def print_usage(config):
    """Prints the command usage guide."""
    print("Usage: ./newbak [backup] <friendlyname|UUID> [rotation]")
    print("       ./newbak <command> <friendlyname|UUID>")
    print("\nCommands:")
    print("  backup <target> [rotation]  Full cycle: open, mount, rsnapshot, unmount, close.")
    print("  open <target>               LUKS open only.")
    print("  force-open <target>         Close existing maps on device, then open.")
    print("  close <target>              Unmount and LUKS close.")
    print("  fsck <target>               Filesystem check (must be open but unmounted).")
    print("  help                        Show this guide.")
    print("\nAvailable Targets:")
    for name, info in config.get('backups', {}).items():
        print(f"  {name:<15} (UUID: {info.get('uuid', 'N/A')}, Mount: {info.get('mountpoint', 'N/A')})")
    sys.exit(0)


def find_config_file():
    """Searches for CONFIG_FILE_NAME in the specified paths."""
    for path in CONFIG_PATHS:
        config_path = path / CONFIG_FILE_NAME
        if config_path.is_file():
            log_operation(f"Loaded configuration from: {config_path}", 'INFO')
            return config_path
    return None


# pylint: disable=inconsistent-return-statements
def load_config(config_path):
    """Loads and validates the backup configuration from the YAML file."""
    try:
        with open(config_path, 'r', encoding='latin1') as f:
            config = yaml.safe_load(f)
        if 'backups' not in config:
            raise ValueError(f"{config_path}: 'backups' key missing.")
        return config
    except Exception as e:
        abort(f"Configuration error: {e}")


def substitute_template(command_list, context):
    """Substitutes ${variables} wherever they appear in command list elements."""
    if not command_list or not isinstance(command_list, list):
        return None

    substituted_list = []
    for item in command_list:
        if not isinstance(item, str):
            substituted_list.append(item)
            continue

        new_item = item
        for var_name, var_value in context.items():
            placeholder = f'${{{var_name}}}'
            new_item = new_item.replace(placeholder, str(var_value))
        substituted_list.append(new_item)

    return substituted_list


def run_command(command_list, check=True, log_output=False, capture_output=True, input_data=None):
    """Executes a shell command using subprocess."""
    if not command_list or not isinstance(command_list, list):
        raise TypeError("Configuration Error: A required command list is missing or invalid.")

    cmd_str = ' '.join(command_list)
    log_operation(f"Executing: {cmd_str}")

    try:
        result = subprocess.run(
            command_list,
            check=check,
            capture_output=capture_output,
            text=True,
            input=input_data
        )

        if log_output and result.stdout:
            for line in result.stdout.strip().split('\n'):
                log_operation(line, type='DEVICE')

        return result
    except subprocess.CalledProcessError as e:
        log_operation(f"Command failed (Exit Code {e.returncode})", 'ERROR')
        if e.stderr:
            for line in e.stderr.strip().split('\n'):
                log_operation(line, type='ERROR')
        raise


def get_device_info(target_id, full_config):
    """Identifies target and finds physical device path."""
    config = full_config['backups']
    friendly_name = None

    if target_id in config:
        info = config[target_id].copy()
        friendly_name = target_id
    else:
        info = next((v.copy() for k, v in config.items() if v.get('uuid') == target_id), None)
        friendly_name = next((k for k, v in config.items() if v.get('uuid') == target_id), None)

    if not info:
        abort(f"Target '{target_id}' not found in configuration.")

    context = full_config.copy()
    context.update(info)
    context['friendlyname'] = friendly_name

    for key in ['uuid', 'mountpoint', 'rsnapshotconf', 'luks_mapname']:
        if key not in context:
            abort(f"Config for '{friendly_name}' missing key: '{key}'")

    cmd = ['lsblk', '-J', '-o', 'NAME,UUID,TYPE']
    result = run_command(cmd, check=True, capture_output=True)
    lsblk_data = json.loads(result.stdout)

    def find_device(nodes):
        for node in nodes:
            if str(node.get('uuid', '')).lower() == context['uuid'].lower() and node.get('type') == 'part':
                return f"/dev/{node['name']}"
            if 'children' in node:
                path = find_device(node['children'])
                if path:
                    return path
        return None

    device_path = find_device(lsblk_data.get('blockdevices', []))
    if not device_path:
        abort(f"No physical device found for UUID {context['uuid']}.")

    context['device'] = device_path
    return context


def find_active_mapname(device_path):
    """Finds active device mapper name associated with physical LUKS path."""
    cmd = ['lsblk', '-J', '-o', 'NAME,KNAME,PKNAME,TYPE']
    try:
        result = subprocess.run(cmd, check=True, capture_output=True, text=True)
        lsblk_data = json.loads(result.stdout)
    except Exception:
        return None

    target_kname = Path(device_path).name

    def search_children(nodes):
        for node in nodes:
            if node.get('kname') == target_kname and node.get('type') == 'part':
                if 'children' in node:
                    for child in node['children']:
                        if child.get('type') in ['crypt', 'dm']:
                            return child.get('name')
                return None
            if 'children' in node:
                map_name = search_children(node['children'])
                if map_name:
                    return map_name
        return None

    return search_children(lsblk_data.get('blockdevices', []))


def check_luks_status(luks_map_name):
    """Checks if the LUKS device is currently open."""
    cmd = ['cryptsetup', 'status', luks_map_name]
    try:
        result = subprocess.run(cmd, check=False, capture_output=True, text=True)
        return result.returncode == 0
    except Exception:
        return False

def is_mounted(mountpoint):
    """Checks if the mountpoint is currently in use."""
    try:
        with open('/proc/mounts', 'r', encoding='latin1') as f:
            mounts = f.read()
            if mountpoint in mounts:
                for line in mounts.splitlines():
                    if line.split()[1] == mountpoint:
                        return True
        return False
    except Exception:
        return False

def verify_mount(mountpoint):
    """Verifies a mount by checking size with df."""
    try:
        cmd = ['df', '-TPh', mountpoint]
        result = run_command(cmd, check=True, capture_output=True)
        lines = result.stdout.strip().split('\n')
        if len(lines) >= 2:
            columns = lines[1].split()
            volsize_re = r'^\d+(\.\d+)?[KMGTPE]$'
            if re.match(volsize_re, columns[2], re.IGNORECASE):
                log_operation(f"\t{lines[1]}", 'INFO')
                return True
        return False
    except Exception:
        return False

def run_open_operation(context, command_line):
    """Handles the core LUKS open process."""
    luks_map_name = context['luks_mapname']
    if check_luks_status(luks_map_name):
        log_operation(f"LUKS device '{luks_map_name}' is already open.", 'INFO')
        return True

    try:
        passphrase = getpass.getpass(f"Passphrase for {context['friendlyname']} ({context['device']}): ")
        input_data = passphrase + '\n'
    except EOFError:
        abort("Passphrase input failed.", command_line)

    open_cmd = substitute_template(context.get('open_command'), context)
    try:
        run_command(open_cmd, check=True, input_data=input_data)
        log_operation("LUKS device successfully opened.", 'INFO')
        return True
    except subprocess.CalledProcessError as e:
        if 'already mapped' in e.stderr:
            log_operation("LUKS open failed: Device busy. Try 'force-open'.", 'ERROR')
            return False
        abort("LUKS open failed. Check passphrase.", command_line)
    return False

def run_unmount_operation(context, command_line):
    """Handles unmount process."""
    mountpoint = context['mountpoint']
    if not is_mounted(mountpoint):
        return

    try:
        log_operation(f"Attempting to unmount {mountpoint}.", 'INFO')
        umount_cmd = substitute_template(context.get('umount_command'), context)
        run_command(umount_cmd, check=True)
    except subprocess.CalledProcessError:
        abort("Aborting due to unmount failure.", command_line)


def do_open(context, command_line):
    """Executes 'open' command."""
    if not run_open_operation(context, command_line):
        abort("Aborting 'open' command due to failure.", command_line)


def do_force_open(context, command_line):
    """
    Closes conflicting system map then opens
    The system remembers/caches a LOT of info on each mapped device.
    See e.g. the output of:
        udevadm info /dev/mapper/evo970ext
    """
    active_map_name = find_active_mapname(context['device'])
    if active_map_name and active_map_name != context['luks_mapname']:
        log_operation(f"Closing conflicting map '{active_map_name}'.", 'WARNING')
        subprocess.run(['cryptsetup', 'close', active_map_name], check=True)

    if not run_open_operation(context, command_line):
        abort("Force-open failed.", command_line)


def do_close(context, command_line):
    """Executes 'close' command."""
    luks_map_name = context['luks_mapname']
    if not check_luks_status(luks_map_name):
        return

    run_unmount_operation(context, command_line)
    close_cmd = substitute_template(context.get('close_command'), context)
    run_command(close_cmd, check=False)

    if check_luks_status(luks_map_name):
        abort("LUKS close failed.", command_line)
    log_operation("LUKS device closed.", 'INFO')


def do_fsck(context, command_line):
    """Executes fsck."""
    luks_map_name = context['luks_mapname']
    if not check_luks_status(luks_map_name):
        log_operation(f"Opening {luks_map_name} for fsck...")
        if not run_open_operation(context, command_line):
            abort("Could not open LUKS device.", command_line)

    run_unmount_operation(context, command_line)

    fsck_cmd = substitute_template(context.get('fsck_command'), context)
    if not fsck_cmd:
        abort("fsck_command not defined in configuration.", command_line)

    try:
        run_command(fsck_cmd, check=True, log_output=True)
        log_operation("fsck completed successfully.")
    except subprocess.CalledProcessError as e:
        if e.returncode == 1:
            log_operation("fsck corrected filesystem errors.", 'WARNING')
        else:
            abort(f"fsck failed (Exit Code {e.returncode})", command_line)


def do_backup(context, command_line):
    """Executes full backup workflow."""
    luks_map_name = context['luks_mapname']
    mountpoint = context['mountpoint']
    opened_by_script = False

    if is_mounted(mountpoint):
        abort(f"Target {mountpoint} is already mounted.", command_line)

    if not check_luks_status(luks_map_name):
        if run_open_operation(context, command_line):
            opened_by_script = True
        else:
            abort("LUKS open failed.", command_line)

    os.makedirs(mountpoint, exist_ok=True)
    mount_cmd = substitute_template(context.get('mount_command'), context)
    try:
        run_command(mount_cmd, check=True)
        if not verify_mount(mountpoint):
            # pylint: disable=broad-exception-raised
            raise Exception("Mount verification failed.")
    except Exception:
        if opened_by_script:
            do_close(context, command_line)
        abort("Mount failure.", command_line)

    try:
        rsnapshot_cmd = substitute_template(context.get('rsnapshot_command'), context)
        run_command(rsnapshot_cmd, check=True, log_output=False)
    except subprocess.CalledProcessError:
        log_operation("Rsnapshot failed.", 'ERROR')

    run_unmount_operation(context, command_line)
    if opened_by_script:
        do_close(context, command_line)


def main():
    """Main Function"""
    if os.geteuid() != 0:
        log_operation("Re-executing with sudo...")
        os.execvp('sudo', ['sudo'] + sys.argv)

    command, target_id, rotation = parse_args(sys.argv[1:])
    config_path = find_config_file()
    if not config_path:
        abort(f"Configuration file '{CONFIG_FILE_NAME}' not found in search paths.")

    full_config = load_config(config_path)
    if command == 'help':
        print_usage(full_config)

    context = get_device_info(target_id, full_config)
    context['rotation'] = rotation
    command_line = f"newbak {' '.join(sys.argv[1:])}"

    log_operation(command_line, 'START')
    if command == 'fsck':
        do_fsck(context, command_line)
    elif command == 'open':
        run_open_operation(context, command_line)
    elif command == 'force-open':
        active = find_active_mapname(context['device'])
        if active:
            run_command(['cryptsetup', 'close', active])
        run_open_operation(context, command_line)
    elif command == 'close':
        run_unmount_operation(context, command_line)
        run_command(substitute_template(context.get('close_command'), context), check=False)
    elif command == 'backup':
        do_backup(context, command_line)

    log_operation(command_line + ' ended', 'END')

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        log_operation(f"CRITICAL ERROR: {e}", 'ERROR')
        sys.exit(1)
